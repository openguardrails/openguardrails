"""
Bypass Token Utility for Private Model Switching

When OG proxies a request to a private model that is also protected by OG,
we need to skip detection for the proxied request to avoid duplicate detection.

This module provides:
- generate_bypass_token(): Create a signed token with tenant_id, request_id, and timestamp
- verify_bypass_token(): Validate the token signature and expiration

Token format: {tenant_id}:{request_id}:{timestamp}:{signature}
Signature: HMAC-SHA256(tenant_id + request_id + timestamp, secret_key)
"""

import hmac
import hashlib
import time
from typing import Optional, Tuple
from config import settings
from utils.logger import setup_logger

logger = setup_logger()

# Header name for bypass token
BYPASS_TOKEN_HEADER = "X-OG-Bypass-Token"

# Token validity period in seconds (5 minutes)
TOKEN_VALIDITY_SECONDS = 300


def _get_secret_key() -> bytes:
    """Get the secret key for signing bypass tokens"""
    # Use JWT_SECRET_KEY from config, which is already used for JWT signing
    return settings.jwt_secret_key.encode('utf-8')


def generate_bypass_token(tenant_id: str, request_id: str) -> str:
    """
    Generate a bypass token for private model requests.

    Args:
        tenant_id: The tenant ID making the request
        request_id: The unique request ID from OG

    Returns:
        A signed token string in format: {tenant_id}:{request_id}:{timestamp}:{signature}
    """
    timestamp = str(int(time.time()))

    # Create message to sign
    message = f"{tenant_id}:{request_id}:{timestamp}"

    # Generate HMAC-SHA256 signature
    signature = hmac.new(
        _get_secret_key(),
        message.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()

    token = f"{tenant_id}:{request_id}:{timestamp}:{signature}"

    logger.debug(f"Generated bypass token for request {request_id}")
    return token


def verify_bypass_token(token: str) -> Tuple[bool, Optional[str], Optional[str]]:
    """
    Verify a bypass token.

    Args:
        token: The token string to verify

    Returns:
        Tuple of (is_valid, tenant_id, request_id)
        - is_valid: True if token is valid and not expired
        - tenant_id: The tenant ID from the token (if valid)
        - request_id: The request ID from the token (if valid)
    """
    if not token:
        return False, None, None

    try:
        parts = token.split(':')
        if len(parts) != 4:
            logger.warning(f"Invalid bypass token format: expected 4 parts, got {len(parts)}")
            return False, None, None

        tenant_id, request_id, timestamp_str, provided_signature = parts

        # Check timestamp validity (not expired)
        try:
            timestamp = int(timestamp_str)
            current_time = int(time.time())

            if current_time - timestamp > TOKEN_VALIDITY_SECONDS:
                logger.warning(f"Bypass token expired: age={(current_time - timestamp)}s > {TOKEN_VALIDITY_SECONDS}s")
                return False, None, None

            # Also check for tokens from the future (clock skew tolerance: 60 seconds)
            if timestamp - current_time > 60:
                logger.warning(f"Bypass token from future: timestamp={timestamp}, current={current_time}")
                return False, None, None

        except ValueError:
            logger.warning(f"Invalid timestamp in bypass token: {timestamp_str}")
            return False, None, None

        # Verify signature
        message = f"{tenant_id}:{request_id}:{timestamp_str}"
        expected_signature = hmac.new(
            _get_secret_key(),
            message.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

        if not hmac.compare_digest(provided_signature, expected_signature):
            logger.warning(f"Invalid bypass token signature for request {request_id}")
            return False, None, None

        logger.info(f"Valid bypass token for request {request_id}, tenant {tenant_id}")
        return True, tenant_id, request_id

    except Exception as e:
        logger.error(f"Error verifying bypass token: {e}")
        return False, None, None


def get_bypass_header() -> str:
    """Get the header name for bypass token"""
    return BYPASS_TOKEN_HEADER
